<!DOCTYPE html>
<html lang="en">
<head>
  <title>Stereo 3D image viewer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="A web-based viewer for stereo 3D images and VR180 photos.">

  <link rel="icon" type="image/svg+xml" href="icons/icon.svg">

  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:creator" content="@steren">
  <meta name="twitter:title" content="Stereo 3D image viewer">
  <meta name="twitter:image" content="https://stereo-viewer.com/icons/title.png">

  <meta property="og:type" content="article">
  <meta property="og:title" content="Stereo 3D image viewer">
  <meta property="og:image" content="https://stereo-viewer.com/icons/title.png">

  <meta name="color-scheme" content="dark">
  <meta name="theme-color" content="#00ff8f">

  <script type="application/ld+json">
  {
    "@context": "http://schema.org",
    "@type": "WebSite",
    "author": "Steren Giannini",
    "name": "Stereo 3D image viewer",
    "image": "https://stereo-viewer.com/icons/title.png"
  }
  </script>

  <!-- Polyfill for WebXR -->
  <script src="https://cdn.jsdelivr.net/npm/webxr-polyfill@latest/build/webxr-polyfill.js"></script>
  <script>
    window.polyfill = new WebXRPolyfill();
  </script>

  <script type="module" src="https://stereo-img.steren.fr/stereo-img.js"></script>

  <style>
    html {
      margin: auto;
      line-height: 1.75;
      font-size: 1.25em;
      font-family: sans-serif;
      background-color: #000;
      color: #fff;
    }

    body {
      margin: 0;
    }

    stereo-img {
      position: absolute;
      left: 0;
      right: 0;
      top: 0;
      bottom: 0;
      z-index: -1;
    }

    #ui {
      visibility: hidden;
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      padding: 20px;
      box-sizing: border-box;
      display: flex;
      justify-content: space-between;
      align-items: center;
      opacity: 0.5;
    }
    #ui:hover {
      opacity: 1;
    }

    .ui-nav {
      display: flex;
      align-items: center;
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
    }

    #thumbnails {
      display: flex;
      overflow-x: auto;
      margin: 0 10px;
      max-width: 50vw;
    }

    #thumbnails img {
      width: 50px;
      height: 50px;
      margin: 0 5px;
      cursor: pointer;
      border: 2px solid transparent;
    }

    #thumbnails img.active {
      border-color: #00ff8f;
    }

    #zero-state {
      display: flex;
	    align-items: center;
	    justify-content: center;
      flex-direction: column;
      height: 100vh;
    }

    #zero-state-icon {
      margin-bottom: 20px;
    }

    #type-selector-container select {
      background-color: #333;
      color: #fff;
      border: 1px solid #555;
      padding: 5px;
      font-family: sans-serif;
    }
  </style>

  <link rel="manifest" href="manifest.json">
</head>

<body id="dropbox">

  <stereo-img></stereo-img>

  <div id="zero-state">
    <img id="zero-state-icon" src="icons/icon-transparent.svg" alt="Stereo Viewer Icon" width="200" height="200">
    <p id="hint">Drag and drop or <label for="file-input">select stereo pictures</label></p>
    <input id="file-input" type="file" accept="image/*" multiple class="visually-hidden">
    <span id="folder-selection-ui" style="display: none;">
      or <button id="folder-input">Select Folder</button>
    </span>
  </div>

  <div id="ui">
    <div class="ui-nav">
      <button id="previous">&larr;</button>
      <div id="thumbnails"></div>
      <button id="next">&rarr;</button>
    </div>
    <div id="type-selector-container">
      <label for="type-select">Type:</label>
      <select id="type-select">
        <option value="auto" selected>Auto</option>
        <option value="pair">Pair</option>
        <option value="vr">VR180</option>
        <option value="left-right">Left-Right</option>
        <option value="right-left">Right-Left</option>
        <option value="top-bottom">Top-Bottom</option>
        <option value="bottom-top">Bottom-Top</option>
        <option value="anaglyph">Anaglyph</option>
      </select>
    </div>
  </div>

  <script>
    ////////////////////////////////////////
    // Global Variables
    ////////////////////////////////////////

    let allFiles = [];
    let currentIndex = 0;


    ////////////////////////////////////////
    // File Handling & Processing
    ////////////////////////////////////////

    /**
     * Processes the files selected by the user.
     * It identifies stereo pairs based on common naming conventions and is case-insensitive to the extension.
     * For example: `image.left.jpg` and `image.right.jpg`, or `photo_L.png` and `photo_R.png`.
     * It then populates `allFiles` with either single file objects or pair objects.
     * @param {FileList} files The files to process.
     */
    function handleFiles(files) {
      console.log("Handling files:", files);
      allFiles = [];
      const fileMap = new Map();

      // Segregate files into pairs and single images
      for (const file of files) {
        if (!file.type.startsWith('image/')) continue;

        const fileName = file.name;
        const dotIndex = fileName.lastIndexOf('.');
        if (dotIndex === -1) {
            allFiles.push(file);
            continue;
        }

        const nameWithoutExt = fileName.substring(0, dotIndex);

        let baseName = null;
        let side = null;

        const leftSuffixes = ['.left', '_left', '-left', '.l', '_l', '-l'];
        const rightSuffixes = ['.right', '_right', '-right', '.r', '_r', '-r'];

        for (const suffix of leftSuffixes) {
            if (nameWithoutExt.toLowerCase().endsWith(suffix)) {
                baseName = nameWithoutExt.substring(0, nameWithoutExt.length - suffix.length);
                side = 'left';
                break;
            }
        }

        if (!baseName) {
            for (const suffix of rightSuffixes) {
                if (nameWithoutExt.toLowerCase().endsWith(suffix)) {
                    baseName = nameWithoutExt.substring(0, nameWithoutExt.length - suffix.length);
                    side = 'right';
                    break;
                }
            }
        }

        if (baseName && side) {
            if (!fileMap.has(baseName)) {
                fileMap.set(baseName, {});
            }
            const pair = fileMap.get(baseName);
            if (side === 'left') {
                pair.left = file;
            } else {
                pair.right = file;
            }
        } else {
            allFiles.push(file);
        }
      }

      // Add completed pairs to the list of files to display
      for (const [baseName, pair] of fileMap.entries()) {
        if (pair.left && pair.right) {
          allFiles.push({
            isPair: true,
            name: baseName,
            left: pair.left,
            right: pair.right
          });
        } else if (pair.left) {
          allFiles.push(pair.left);
        } else if (pair.right) {
          allFiles.push(pair.right);
        }
      }

      if (allFiles.length > 0) {
        currentIndex = 0;
        displayFile(allFiles[currentIndex]);
        generateThumbnails();
      } else {
        document.querySelector('stereo-img').src = '';
        document.getElementById('zero-state').style.display = 'flex';
        clearThumbnails();
      }
      updateButtonStates();
    }

    /**
     * Displays a file or a pair of files in the stereo-img component.
     * @param {File|object} fileOrPair The file or pair object to display.
     */
    function displayFile(fileOrPair) {
      // If it's a pair, read both files and process them together.
      if (fileOrPair.isPair) {
        const readerLeft = new FileReader();
        const readerRight = new FileReader();
        let leftUrl, rightUrl;

        readerLeft.onload = e => {
          leftUrl = e.target.result;
          if (rightUrl) {
            displayPair(leftUrl, rightUrl, fileOrPair.name);
          }
        };

        readerRight.onload = e => {
          rightUrl = e.target.result;
          if (leftUrl) {
            displayPair(leftUrl, rightUrl, fileOrPair.name);
          }
        };

        readerLeft.readAsDataURL(fileOrPair.left);
        readerRight.readAsDataURL(fileOrPair.right);
      } else {
        // If it's a single file, read and process it.
        let reader = new FileReader();
        reader.onload = e => { displaySingleFile(e.target.result, fileOrPair.name); };
        reader.readAsDataURL(fileOrPair);
      }
    }

    /**
     * Configures the stereo-img component to display a pair of images.
     * @param {string} leftUrl The data URL for the left image.
     * @param {string} rightUrl The data URL for the right image.
     * @param {string} fileName The base name of the image pair.
     */
    function displayPair(leftUrl, rightUrl, fileName) {
      console.log("Processing pair:", fileName);
      const stereoImg = document.querySelector('stereo-img');
      stereoImg.setAttribute('type', 'pair');
      stereoImg.setAttribute('src-right', rightUrl);
      stereoImg.src = leftUrl;
      document.getElementById('type-select').value = 'pair';
      hideZeroState();
    }

    /**
     * Configures the stereo-img component to display a single image.
     * @param {string} url The data URL for the image.
     * @param {string} fileName The name of the file.
     */
    function displaySingleFile(url, fileName) {
      console.log("Processing file:", fileName);
      const stereoImg = document.querySelector('stereo-img');
      // Reset attributes to default for a single image
      stereoImg.removeAttribute('type');
      stereoImg.removeAttribute('src-right');
      stereoImg.src = url;
      document.getElementById('type-select').value = 'auto';
      hideZeroState();
    }


    ////////////////////////////////////////
    // UI & Thumbnail Management
    ////////////////////////////////////////

    function hideZeroState() {
      document.getElementById('zero-state').style.display = 'none';
    }

    function updateButtonStates() {
      const typeSelectorContainer = document.getElementById('type-selector-container');
      if (allFiles.length === 0) {
        document.getElementById('ui').style.visibility = 'hidden';
        typeSelectorContainer.style.visibility = 'hidden';
        document.getElementById('previous').disabled = true;
        document.getElementById('next').disabled = true;
        return;
      }
      document.getElementById('ui').style.visibility = 'visible';
      typeSelectorContainer.style.visibility = 'visible';
      document.getElementById('previous').disabled = currentIndex === 0;
      document.getElementById('next').disabled = currentIndex === allFiles.length - 1;
    }

    /**
     * Generates thumbnails for all loaded files and pairs.
     */
    function generateThumbnails() {
      const thumbnailsContainer = document.getElementById('thumbnails');
      thumbnailsContainer.innerHTML = '';

      allFiles.forEach((fileOrPair, index) => {
        const img = document.createElement('img');
        img.addEventListener('click', () => {
          currentIndex = index;
          displayFile(allFiles[currentIndex]);
          updateActiveThumbnail();
        });
        thumbnailsContainer.appendChild(img);

        const reader = new FileReader();
        reader.onload = e => {
          img.src = e.target.result;
        };
        
        // For pairs, use the left image for the thumbnail.
        if (fileOrPair.isPair) {
          reader.readAsDataURL(fileOrPair.left);
        } else {
          reader.readAsDataURL(fileOrPair);
        }
      });
      updateActiveThumbnail();
    }

    function clearThumbnails() {
      const thumbnailsContainer = document.getElementById('thumbnails');
      thumbnailsContainer.innerHTML = '';
    }

    function updateActiveThumbnail() {
      const thumbnails = document.querySelectorAll('#thumbnails img');
      thumbnails.forEach((thumbnail, index) => {
        if (index === currentIndex) {
          thumbnail.classList.add('active');
        } else {
          thumbnail.classList.remove('active');
        }
      });
    }

    ////////////////////////////////////////
    // Event Listeners
    ////////////////////////////////////////

    // File input
    document.getElementById("file-input").addEventListener("change", (e) => {
      handleFiles(e.target.files);
    }, false);

    // Previous/Next buttons
    document.getElementById("previous").addEventListener("click", () => {
      if (currentIndex > 0) {
        currentIndex--;
        displayFile(allFiles[currentIndex]);
        updateButtonStates();
        updateActiveThumbnail();
      }
    });

    document.getElementById("next").addEventListener("click", () => {
      if (currentIndex < allFiles.length - 1) {
        currentIndex++;
        displayFile(allFiles[currentIndex]);
        updateButtonStates();
        updateActiveThumbnail();
      }
    });

    // Keyboard navigation
    document.addEventListener('keydown', (e) => {
      if (e.key === 'ArrowLeft') {
        document.getElementById('previous').click();
      } else if (e.key === 'ArrowRight') {
        document.getElementById('next').click();
      }
    });

    // Type selector
    document.getElementById('type-select').addEventListener('change', (e) => {
      const stereoImg = document.querySelector('stereo-img');
      const selectedType = e.target.value;

      if (selectedType === 'auto') {
        stereoImg.removeAttribute('type');
      } else {
        stereoImg.setAttribute('type', selectedType);
      }
    });


    ////////////////////////////////////////
    // File selection
    ////////////////////////////////////////

    // Folder selection
    if ('showDirectoryPicker' in window) {
      document.getElementById('folder-selection-ui').style.display = 'inline';
      const folderInput = document.getElementById('folder-input');
      folderInput.addEventListener('click', async () => {
        try {
          const dirHandle = await window.showDirectoryPicker();
          const files = [];
          for await (const entry of dirHandle.values()) {
            if (entry.kind === 'file') {
              const file = await entry.getFile();
              if (file.type.startsWith('image/')) {
                files.push(file);
              }
            }
          }
          handleFiles(files);
        } catch (e) {
          if (e.name !== 'AbortError') {
            console.error(e);
          }
        }
      });
    }

    // Drag and drop
    const dropzone = document.getElementById("dropbox");
    dropzone.ondragover = dropzone.ondragenter = (e) => {
      e.stopPropagation();
      e.preventDefault();
    }
    dropzone.ondrop = (e) => {
      e.stopPropagation();
      e.preventDefault();
      console.log("Files dropped");
      handleFiles(e.dataTransfer.files);
    }

    // File Handling API
    if ('launchQueue' in window && 'files' in LaunchParams.prototype) {
      launchQueue.setConsumer(async (launchParams) => {
        if (!launchParams.files.length) {
          return;
        }
        console.log("File(s) to Handle (File Handling API)");
        const files = await Promise.all(launchParams.files.map( (fileHandle) => {return fileHandle.getFile();} ));
        handleFiles(files);
      });
    }

    ////////////////////////////////////////
    // Service Worker
    ////////////////////////////////////////

    navigator.serviceWorker.register('sw.js')
    navigator.serviceWorker.addEventListener('message', event => {
      if(event.files) {
        handleFiles(event.files);
      }
    });

    ////////////////////////////////////////
    // Initialization
    ////////////////////////////////////////

    updateButtonStates();

  </script>

</body>
</html>
